version 4.0

class ZRadarMainHandler : EventHandler
{
	enum BatteryLevels
	{
		Battery_Level_1 = 25,
		Battery_Level_2 = 75,
		Battery_Level_3 = 100,  // [Ace] Currently unused.
	}

	enum BlipType
	{
		Blip_Hostile,
		Blip_Friendly,
		Blip_Player,
		Blip_FragShard
	}

	// ----------------------------------------------------------
	// CORE
	// ----------------------------------------------------------

	private transient CVar DefaultRadarMode;

	private transient CVar RadarPosition;
	private transient CVar RadarScale;
	private transient CVar RadarOpacity;
	private transient CVar RadarDistance;
	private transient CVar RadarColor;

	private transient CVar BatteryEnabled;
	private transient CVar BatteryDrainRate;
	private transient CVar BatteryRechargeRate;

	private transient Array<Actor> MonstersFound;
	private int RadarMode[8];
	private int BatteryPower[8];

	override void OnRegister()
	{
		DefaultRadarMode = CVar.GetCVar("zradar_defmode", players[consoleplayer]);

		RadarPosition = CVar.GetCVar("zradar_position", players[consoleplayer]);
		RadarScale = CVar.GetCVar("zradar_scale", players[consoleplayer]);
		RadarOpacity = CVar.GetCVar("zradar_opacity", players[consoleplayer]);
		RadarDistance = CVar.GetCVar("zradar_distance", players[consoleplayer]);
		RadarColor = CVar.GetCVar("zradar_color", players[consoleplayer]);

		BatteryEnabled = CVar.GetCVar("zradar_battery_enable", players[consoleplayer]);
		BatteryDrainRate = CVar.GetCVar("zradar_battery_drain", players[consoleplayer]);
		BatteryRechargeRate = CVar.GetCVar("zradar_battery_recharge", players[consoleplayer]);

		BatteryPower[consoleplayer] = 100;
		RadarMode[consoleplayer] = BatteryEnabled.GetBool() ? GetRadarMode(BatteryPower[consoleplayer]) : DefaultRadarMode.GetInt();
	}

	private transient int DrainTics;
	private transient int RechargeTics;

	override void WorldTick()
	{
		int DrainRate = BatteryDrainRate.GetInt();
		int RechargeRate = BatteryRechargeRate.GetInt();
		int CurrMode = RadarMode[consoleplayer];

		// [Ace] Battery stuff.
		if (BatteryEnabled.GetBool())
		{
			// [Ace] Draining.
			if (CurrMode > 0 && DrainTics++ == DrainRate)
			{
				BatteryPower[consoleplayer]--;
				CurrMode = GetRadarMode(BatteryPower[consoleplayer]);

				if (BatteryPower[consoleplayer] <= 0)
				{
					CurrMode = 0;
					let plr = players[consoleplayer].mo;
					if (plr)
					{
						plr.A_Print("\c[Orange]Scanner Deactivated");
						plr.A_StartSound("GenAlert", 7, CHANF_UI | CHANF_LOCAL | CHANF_OVERLAP);
					}
				}

				DrainTics = 0;
			}

			// [Ace] Recharging.
			else if (CurrMode == 0 && BatteryPower[consoleplayer] < 100 && RechargeTics++ == RechargeRate)
			{
				let plr = players[consoleplayer].mo;
				if (plr && ++BatteryPower[consoleplayer] == 100)
				{
					plr.A_Print("\c[Cyan]Scanner fully charged!");
					plr.A_StartSound("GenAlert", 7, CHANF_UI | CHANF_LOCAL | CHANF_OVERLAP);
				}

				RechargeTics = 0;
			}
		}

		// [Ace] This is where enemies are updated.
		if (CurrMode > 0)
		{
			MonstersFound.Clear();

			BlockThingsIterator it = BlockThingsIterator.Create(players[consoleplayer].mo, RadarDistance.GetInt());
			while (it.Next())
			{
				if (Type == -1 || it.Thing == players[consoleplayer].mo || it.Thing.Health <= 0 || players[consoleplayer].mo.Distance2D(it.Thing) + it.Thing.Speed > RadarDistance.GetInt()) continue;
				
				BlipType Type = ClassifyActor(it.Thing);
				if (CurrMode == 1 && players[consoleplayer].mo.CheckSight(it.Thing) || CurrMode == 2 && (it.Thing.vel.length() > 1 || it.Thing.target) || CurrMode == 3 || Type >= Blip_Player)
				{
					MonstersFound.Push(it.Thing);
				}
			}
		}

		RadarMode[consoleplayer] = CurrMode;
	}

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "ChangeRadarMode")
		{
			int CurrMode = RadarMode[consoleplayer];
			if (BatteryEnabled.GetBool())
			{
				CurrMode = CurrMode == 0 ? GetRadarMode(BatteryPower[consoleplayer]) : 0;
			}
			else
			{
				++CurrMode %= 4;
			}

			string Message = "";
			switch (CurrMode)
			{
				case 0: Message = "\c[Orange]Scanner Deactivated"; break;
				case 1: Message = "\c[Red]Local Scanner Activated"; break;
				case 2: Message = "\c[Yellow]Movement Scanner Activated"; break;
				case 3: Message = "\c[Green]Full Scanner Activated"; break;
			}
			RadarMode[consoleplayer] = CurrMode;

			let plr = players[consoleplayer].mo;
			if (plr)
			{
				plr.A_Print(Message);
				plr.A_StartSound("GenAlert", 7, CHANF_UI | CHANF_LOCAL | CHANF_OVERLAP);
			}
		}
	}

	// ----------------------------------------------------------
	// UI
	// ----------------------------------------------------------

	const RadarFrames = 12;
	static const string RadarGraphics[] =
	{
		"RADAR1", "R1SAFEZ0", "R1SAFEZ1", "R1SAFEZ2", "R1SAFEZ3", "R1SAFEZ4", "R1SAFEZ5", "R1SAFEZ6", "R1SAFEZ7", "R1SAFEZ8", "R1SAFEZ9", "R1SAFEZA",
		"RADAR2", "R2SAFEZ0", "R2SAFEZ1", "R2SAFEZ2", "R2SAFEZ3", "R2SAFEZ4", "R2SAFEZ5", "R2SAFEZ6", "R2SAFEZ7", "R2SAFEZ8", "R2SAFEZ9", "R2SAFEZA"
	};

	const FontName = "ZRDRFONT";

	private transient ui HUDFont mMainFont;

	private transient ui int Frame;
	private transient ui int CircleUpdateTics;

	override void RenderUnderlay(RenderEvent e)
	{
		mMainFont = HUDFont.Create(FontName);

		int OriginalWidth = StatusBar.HorizontalResolution;
		int OriginalHeight = StatusBar.VerticalResolution;

		double OriginalAlpha = RadarOpacity.GetFloat();
		double Scale = RadarScale.GetFloat();
		int Position = RadarPosition.GetInt();

		if (RadarMode[consoleplayer] > 0)
		{
			StatusBar.SetSize(StatusBar.RelTop, int(640 / Scale), int(480 / Scale));
			StatusBar.BeginHUD(1.0, true);

			// --------------- SHARED ---------------

			double Alpha = OriginalAlpha;
			if (BatteryEnabled.GetBool() && BatteryPower[consoleplayer] < Battery_Level_2)
			{
				double Mult = BatteryPower[consoleplayer] / double(Battery_Level_2);
				Alpha = OriginalAlpha * (Mult > 0.35 ? Mult : 0.35);
			}

			// --------------- CIRCLE ---------------

			if (CircleUpdateTics++ == 9)
			{
				Frame++;
				Frame %= RadarFrames;

				CircleUpdateTics = 0;
			}

			vector2 RadarPos; int DrawFlags;
			[RadarPos, DrawFlags] = GetPositionData(Position);
			StatusBar.DrawImage(RadarGraphics[12 * RadarColor.GetInt() + Frame], RadarPos, DrawFlags, Alpha);

			// --------------- CROSS ---------------

			int CrossColor = 0;
			switch (RadarMode[consoleplayer])
			{
				case 1: CrossColor = Font.CR_RED; break;
				case 2: CrossColor = Font.CR_YELLOW; break;
				case 3: CrossColor = Font.CR_GREEN; break;
			}
			StatusBar.DrawString(mMainFont, "+", (RadarPos.x - 4, RadarPos.y - 4), DrawFlags, CrossColor, Alpha);

			// --------------- BLIPS N STUFF ---------------

			for (int i = 0; i < MonstersFound.Size(); ++i)
			{
				double Scale = 17 * (RadarDistance.GetInt() / 1000.0);
				DrawBlip(StatusBar, StatusBar.CPlayer.mo, MonstersFound[i], RadarPos, DrawFlags, ClassifyActor(MonstersFound[i]), Scale, Alpha);
			}

			// --------------- PRETEND WE WERE NEVER HERE ---------------

			StatusBar.SetSize(StatusBar.RelTop, OriginalWidth, OriginalHeight);
		}
	}

	private ui void DrawBlip(BaseStatusBar sbar, Actor src, Actor trgt, vector2 drawPos, int flags, BlipType blipType, double scale, double alpha)
	{
		if (!src || !trgt) return;

		vector3 dif = (src.pos.x - trgt.pos.x, src.pos.y - trgt.pos.y, trgt.pos.z - src.pos.z);

		// [Ace] This part of the code (the one with the maths) is the only one that doesn't directly belong to me. I don't know what the variables are supposed to mean because they use ye olde Ken Silverman naming conventions
		// and make fuck all sense to everyone else but the author. Name your damn variables properly! Anyway, I think the 'd' stands for "draw".
		double dx = dif.x * cos(-src.Angle) - dif.y * sin(-src.Angle);
		double dy = dif.x * sin(-src.Angle) + dif.y * cos(-src.Angle);
		dx /= scale; dx += drawPos.y;
		dy /= scale; dy += drawPos.x;

		string BlipImage = "";
		switch (blipType)
		{
			case Blip_Hostile:
				if (trgt.Health >= 1000)
				{
					BlipImage = dif.z <= -30 ? "GLDBELOW" : (dif.z >= 30 ? "GLDABOVE" : "GLDDOT");
				}
				else
				{
					BlipImage = dif.z <= -30 ? "REDBELOW" : (dif.z >= 30 ? "REDABOVE" : "REDDOT");
				}
				break;

			case Blip_Friendly:
				BlipImage = dif.z <= -30 ? "CYNBELOW" : (dif.z >= 30 ? "CYNABOVE" : "CYNDOT");
				break;

			case Blip_Player:
				BlipImage = dif.z <= -30 ? "REDBELOW" : (dif.z >= 30 ? "REDABOVE" : "REDDOT");
				break;

			case Blip_FragShard:
				BlipImage = "FRAGSHRD";
				break;
		}
		
		StatusBar.DrawImage(BlipImage, (dy, dx), flags, alpha);
	}

	// ----------------------------------------------------------
	// INFORMATION
	// ----------------------------------------------------------

	private BlipType ClassifyActor(Actor a) const
	{
		if (a.GetClassName() == 'BFGNecroShard') return Blip_FragShard;
		if (a is "PlayerPawn") return Blip_Player;
		if (a.bISMONSTER) return a.bFRIENDLY ? Blip_Friendly : Blip_Hostile;
		
		return -1;
	}

	private int GetRadarMode(int power) const
	{
		     if (power < Battery_Level_1) return 1;
		else if (power < Battery_Level_2) return 2;
		
		return 3;
	}

	private ui vector2, int GetPositionData(int position) const
	{
		vector2 pos; int flags;
		switch (position)
		{
			case 0:
				flags = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_ITEM_CENTER;
				pos = (65, 65);
				break;
			case 1:
				flags = BaseStatusBar.DI_SCREEN_RIGHT_TOP | BaseStatusBar.DI_ITEM_CENTER;
				pos = (-65, 65);
				break;
			case 2:
				flags = BaseStatusBar.DI_SCREEN_LEFT_BOTTOM | BaseStatusBar.DI_ITEM_CENTER;
				pos = (65, -65);
				break;
			case 3:
				flags = BaseStatusBar.DI_SCREEN_RIGHT_BOTTOM | BaseStatusBar.DI_ITEM_CENTER;
				pos = (-65, -65);
				break;
		}

		return pos, flags;
	}
}