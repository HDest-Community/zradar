version 4.0

enum BlipType
{
	Blip_Hostile,
	Blip_PowerfulHostile,
	Blip_Friendly,
	Blip_Player,
	Blip_FragShard
}

enum RMode
{
	Mode_Disabled,
	Mode_Full,
	Mode_Movement,
	Mode_Local
}

enum UnitType
{
	Unit_MapUnit = 1,
	Unit_HDMeter
}

class RadarBlip
{
	double PlayerAngle;
	vector3 PlayerPos;
	vector3 TargetPos;
	BlipType Type;
}

class ZRadarMainHandler : EventHandler
{
	// ----------------------------------------------------------
	// CORE
	// ----------------------------------------------------------

	private transient CVar DefaultRadarMode;

	private transient CVar RadarDrawOverHud;
	private transient CVar RadarPosition;
	private transient CVar RadarScale;
	private transient CVar RadarOpacity;
	private transient CVar RadarColor;
	private transient CVar RadarRangeUnits;
	private transient CVar RadarRangeDivisions;
	private transient CVar RadarFrameTics;

	private transient CVar RadarDistance;
	private transient CVar RadarRefreshRate;

	private transient CVar BatteryEnabled;
	private transient CVar BatteryDrainTime;
	private transient CVar BatteryRechargeTime;

	private transient Array<RadarBlip> RadarBlips;
	private int RadarMode[8];
	private int BatteryPower[8];
	private int AccumulatedDrain[8];

	private transient int ArrayRefreshTics;

	override void OnRegister()
	{
		DefaultRadarMode = CVar.GetCVar("zradar_defmode", players[consoleplayer]);

		RadarDrawOverHud = CVar.GetCVar("zradar_drawoverhud", players[consoleplayer]);
		RadarPosition = CVar.GetCVar("zradar_position", players[consoleplayer]);
		RadarScale = CVar.GetCVar("zradar_scale", players[consoleplayer]);
		RadarOpacity = CVar.GetCVar("zradar_opacity", players[consoleplayer]);
		RadarColor = CVar.GetCVar("zradar_color", players[consoleplayer]);
		RadarRangeUnits = CVar.GetCVar("zradar_rangeunits", players[consoleplayer]);
		RadarRangeDivisions = CVar.GetCVar("zradar_rangedivisions", players[consoleplayer]);
		RadarFrameTics = CVar.GetCVar("zradar_frametics", players[consoleplayer]);

		RadarDistance = CVar.GetCVar("zradar_distance", players[consoleplayer]);
		RadarRefreshRate = CVar.GetCVar("zradar_refreshrate", players[consoleplayer]);
		
		BatteryEnabled = CVar.GetCVar("zradar_battery_enable", players[consoleplayer]);
		BatteryDrainTime = CVar.GetCVar("zradar_battery_draintime", players[consoleplayer]);
		BatteryRechargeTime = CVar.GetCVar("zradar_battery_rechargetime", players[consoleplayer]);
	}

	override void WorldLoaded(WorldEvent e)
	{
		BatteryPower[consoleplayer] = 100;
		RadarMode[consoleplayer] = DefaultRadarMode.GetInt();
	}

	override void WorldTick()
	{
		if (GameState != GS_LEVEL) return;

		int DrainTime = int(35 * 60 * BatteryDrainTime.GetFloat() * GetDrainMult(RadarMode[consoleplayer]));
		int RechargeTime = int(35 * 60 * BatteryRechargeTime.GetFloat());

		// [Ace] Battery stuff.
		if (BatteryEnabled.GetBool())
		{
			// [Ace] Draining.
			if (RadarMode[consoleplayer] > Mode_Disabled)
			{
				BatteryPower[consoleplayer] = int((1.0 - AccumulatedDrain[consoleplayer]++ / double(DrainTime)) * 100);

				if (BatteryPower[consoleplayer] <= 0)
				{
					RadarMode[consoleplayer] = Mode_Disabled;
					let plr = players[consoleplayer].mo;
					if (plr)
					{
						plr.A_Print("\c[Orange]Scanner Deactivated\c-", 1);
						plr.A_StartSound("GenAlert", 7, CHANF_UI | CHANF_LOCAL | CHANF_OVERLAP);
					}
				}
			}

			// [Ace] Recharging.
			else if (RadarMode[consoleplayer] == Mode_Disabled && BatteryPower[consoleplayer] < 100)
			{
				BatteryPower[consoleplayer] = int((1.0 - AccumulatedDrain[consoleplayer]-- / double(DrainTime)) * 100);

				let plr = players[consoleplayer].mo;
				if (plr && BatteryPower[consoleplayer] == 100)
				{
					plr.A_Print("\c[Cyan]Scanner fully charged!\c-", 2);
					plr.A_StartSound("GenAlert", 7, CHANF_UI | CHANF_LOCAL | CHANF_OVERLAP);
				}
			}
		}

		// [Ace] This is where enemies are updated.
		if (RadarMode[consoleplayer] > Mode_Disabled && ArrayRefreshTics++ >= RadarRefreshRate.GetInt())
		{
			RadarBlips.Clear();

			BlockThingsIterator it = BlockThingsIterator.Create(players[consoleplayer].mo, RadarDistance.GetInt());
			while (it.Next())
			{
				BlipType Type = ClassifyActor(it.Thing);
				if (Type == -1 || it.Thing == players[consoleplayer].mo || it.Thing.Health <= 0 || players[consoleplayer].mo.Distance2D(it.Thing) - it.Thing.Radius + it.Thing.vel.length() > RadarDistance.GetInt()) continue;

				if (RadarMode[consoleplayer] == Mode_Local && players[consoleplayer].mo.CheckSight(it.Thing) || RadarMode[consoleplayer] == Mode_Movement && (it.Thing.vel.length() > 0 || it.Thing.target || it.Thing.master && it.Thing.master && it.Thing.master is "PlayerPawn") || RadarMode[consoleplayer] == Mode_Full || Type >= Blip_Player)
				{
					let Blip = new("RadarBlip");
					Blip.Type = Type;
					Blip.TargetPos = it.Thing.pos;
					Blip.PlayerPos = players[consoleplayer].mo.pos;
					Blip.PlayerAngle = players[consoleplayer].mo.Angle;

					RadarBlips.Push(Blip);
				}
			}

			ArrayRefreshTics = 0;
		}
	}

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "ChangeRadarMode")
		{
			// [Ace] Force radar refresh when you switch modes.
			ArrayRefreshTics = RadarRefreshRate.GetInt();
			
			++RadarMode[e.Player] %= 4;

			string Message = "";
			switch (RadarMode[e.Player])
			{
				case Mode_Disabled: Message = "\c[Orange]Scanner Deactivated\c-"; break;
				case Mode_Full: Message = "\c[Green]Full Scanner Activated\c-"; break;
				case Mode_Movement: Message = "\c[Yellow]Movement Scanner Activated\c-"; break;
				case Mode_Local: Message = "\c[Red]Local Scanner Activated\c-"; break;	
			}

			let plr = players[e.Player].mo;
			if (plr)
			{
				plr.A_Print(Message, 1);
				plr.A_StartSound("GenAlert", 7, CHANF_UI | CHANF_LOCAL | CHANF_OVERLAP);
			}
		}
	}

	// ----------------------------------------------------------
	// UI
	// ----------------------------------------------------------

	const RadarFrames = 12;

	const FontName = "ZRDRFONT";

	private transient ui HUDFont mMainFont;

	private transient ui int Frame;
	private transient ui int CircleUpdateTics;

	override void RenderUnderlay(RenderEvent e)
	{
		if (!RadarDrawOverHud.GetBool())
		{
			DrawRadar();
		}
	}

	override void RenderOverlay(RenderEvent e)
	{
		if (RadarDrawOverHud.GetBool())
		{
			DrawRadar();
		}
	}

	private ui void DrawRadar()
	{
		if (GameState != GS_LEVEL || AutomapActive) return;
		
		mMainFont = HUDFont.Create(FontName);

		int OriginalWidth = StatusBar.HorizontalResolution;
		int OriginalHeight = StatusBar.VerticalResolution;

		double OriginalAlpha = RadarOpacity.GetFloat();
		double Scale = RadarScale.GetFloat();
		int Position = RadarPosition.GetInt();
		int RefreshRate = RadarRefreshRate.GetInt();

		if (RadarMode[consoleplayer] > Mode_Disabled)
		{
			StatusBar.BeginHUD(1.0, true);
			StatusBar.SetSize(StatusBar.RelTop, int(640 / Scale), int(480 / Scale));

			// --------------- SHARED ---------------

			double Alpha = OriginalAlpha;
			if (BatteryEnabled.GetBool())
			{
				double Mult = BatteryPower[consoleplayer] / 100.0;
				Alpha *= max(0.35, Mult);
			}

			// --------------- CIRCLE ---------------

			if (CircleUpdateTics++ >= RadarFrameTics.GetInt())
			{
				Frame++;
				Frame %= RadarFrames + 1;

				CircleUpdateTics = 0;
			}

			int RadCol = RadarColor.GetInt();
			vector2 RadarPos; int DrawFlags;
			[RadarPos, DrawFlags] = GetPositionData(Position);

			// [Ace] Main.
			StatusBar.DrawImage("R"..RadCol.."MAIN", RadarPos, DrawFlags, Alpha);

			// [Ace] Scan circle.
			vector2 ScanScale = (1.0, 1.0);
			ScanScale *= Frame / double(RadarFrames);
			StatusBar.DrawImage("R"..RadCol.."SCAN", RadarPos, DrawFlags, Alpha, scale: ScanScale);

			// [Ace] Range circles.
			int RangeUnits = RadarRangeUnits.GetInt();
			if (RangeUnits > 0)
			{
				int RangeColor = 0;
				switch (RadCol)
				{
					case 0: RangeColor = Font.CR_LIGHTBLUE; break;
					case 1: RangeColor = Font.CR_GREEN; break;
				}

				int RangeDivisions = RadarRangeDivisions.GetInt();
				for (int i = 1; i <= RangeDivisions; ++i)
				{
					string RangeString = "";
					switch (RangeUnits)
					{
						case Unit_MapUnit: RangeString = StatusBar.FormatNumber(int(RadarDistance.GetInt() / double(RangeDivisions) * i), 1, 4); break;
						case Unit_HDMeter: RangeString = StatusBar.FormatNumber(int(RadarDistance.GetInt() / double(RangeDivisions) / 42.0 * i), 1, 3).."m"; break;
					}

					// [Ace] Circle.
					vector2 RangeCircleScale = (1.0, 1.0);
					RangeCircleScale *= i / double(RangeDivisions);
					StatusBar.DrawImage("R"..RadCol.."RANGE", RadarPos, DrawFlags, Alpha * 0.60, scale: RangeCircleScale);

					// [Ace] Number.
					StatusBar.DrawString(mMainFont, RangeString, (RadarPos.x - 1, RadarPos.y + 2 - 60 / RangeDivisions * i), DrawFlags | BaseStatusBar.DI_TEXT_ALIGN_CENTER, RangeColor, Alpha * 0.60);
				}
			}

			// --------------- CROSS ---------------

			int CrossColor = 0;
			switch (RadarMode[consoleplayer])
			{
				case Mode_Local: CrossColor = Font.CR_RED; break;
				case Mode_Movement: CrossColor = Font.CR_YELLOW; break;
				case Mode_Full: CrossColor = Font.CR_GREEN; break;
			}
			StatusBar.DrawString(mMainFont, "+", (RadarPos.x - 4, RadarPos.y - 4), DrawFlags, CrossColor, Alpha);

			// --------------- BLIPS N STUFF ---------------

			Alpha *= RefreshRate > 1 ? 1.0 - ArrayRefreshTics / double(RefreshRate) : 1.0;

			for (int i = 0; i < RadarBlips.Size(); ++i)
			{
				double Scale = 17 * (RadarDistance.GetInt() / 1000.0);
				DrawBlip(StatusBar, RadarBlips[i], RadarPos, DrawFlags, Scale, Alpha);
			}

			// --------------- PRETEND WE WERE NEVER HERE ---------------

			StatusBar.BeginHUD(1.0, false);
			StatusBar.SetSize(StatusBar.RelTop, OriginalWidth, OriginalHeight);
		}
	}

	private ui void DrawBlip(BaseStatusBar sbar, RadarBlip blip, vector2 drawPos, int flags, double scale, double alpha)
	{
		if (!blip) return;

		vector3 dif = (blip.PlayerPos.x - Blip.TargetPos.x, blip.PlayerPos.y - blip.TargetPos.y, blip.TargetPos.z - Blip.PlayerPos.z);

		// [Ace] This part of the code (the one with the maths) is the only one that doesn't directly belong to me. I don't know what the variables are supposed to mean because they use ye olde Ken Silverman naming conventions
		// and make fuck all sense to everyone else but the author. Name your damn variables properly! Anyway, I think the 'd' stands for "draw".
		double dx = dif.x * cos(-Blip.PlayerAngle) - dif.y * sin(-Blip.PlayerAngle);
		double dy = dif.x * sin(-Blip.PlayerAngle) + dif.y * cos(-Blip.PlayerAngle);
		dx /= scale; dx += drawPos.y;
		dy /= scale; dy += drawPos.x;

		string BlipImage = "";
		switch (blip.Type)
		{
			case Blip_Hostile:
				BlipImage = dif.z <= -60 ? "REDBELOW" : (dif.z >= 60 ? "REDABOVE" : "REDDOT");
				break;

			case Blip_PowerfulHostile:
				BlipImage = dif.z <= -60 ? "GLDBELOW" : (dif.z >= 60 ? "GLDABOVE" : "GLDDOT");
				break;

			case Blip_Friendly:
				BlipImage = dif.z <= -60 ? "CYNBELOW" : (dif.z >= 60 ? "CYNABOVE" : "CYNDOT");
				break;

			case Blip_Player:
				BlipImage = dif.z <= -60 ? "GRNBELOW" : (dif.z >= 60 ? "GRNABOVE" : "GRNDOT");
				break;

			case Blip_FragShard:
				BlipImage = "FRAGSHRD";
				break;
		}
		
		StatusBar.DrawImage(BlipImage, (dy, dx), flags, alpha);
	}

	// ----------------------------------------------------------
	// INFORMATION
	// ----------------------------------------------------------

	private double GetDrainMult(RMode mode) const
	{
		switch (mode)
		{
			case Mode_Local: return 2.0;
			case Mode_Movement: return 1.5;
			case Mode_Full: return 1.0;
		}

		return 1.0;
	}

	private BlipType ClassifyActor(Actor a) const
	{
		if (a.GetClassName() == 'BFGNecroShard') return Blip_FragShard;
		if (a is "PlayerPawn") return Blip_Player;
		if (a.bISMONSTER) return a.bFRIENDLY ? Blip_Friendly : (a.GetSpawnHealth() >= 1000 ? Blip_PowerfulHostile : Blip_Hostile);
		
		return -1;
	}

	private ui vector2, int GetPositionData(int position) const
	{
		vector2 pos; int flags;
		switch (position)
		{
			case 0:
				flags = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_ITEM_CENTER;
				pos = (65, 65);
				break;
			case 1:
				flags = BaseStatusBar.DI_SCREEN_RIGHT_TOP | BaseStatusBar.DI_ITEM_CENTER;
				pos = (-65, 65);
				break;
			case 2:
				flags = BaseStatusBar.DI_SCREEN_LEFT_BOTTOM | BaseStatusBar.DI_ITEM_CENTER;
				pos = (65, -65);
				break;
			case 3:
				flags = BaseStatusBar.DI_SCREEN_RIGHT_BOTTOM | BaseStatusBar.DI_ITEM_CENTER;
				pos = (-65, -65);
				break;
		}

		return pos, flags;
	}
}